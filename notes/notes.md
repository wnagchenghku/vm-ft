## LD_DEBUG
Output verbose debugging information about the dynamic linker. If set to all prints all debugging information it has.


## make
```
-n, --just-print, --dry-run, --recon
     Print the commands that would be executed, but do not execute them.
```

## Source Code to Executable
The compilation of a source code into an executable takes place in 4 stages, Preprocessing, Compilation, Assembly and linking. Let us consider the following C source code example before we discuss concepts further.
```
#include <stdio.h>

#define AVALUE 5

int main()
{
	float a = AVALUE;
	float b = 25;

	// calculate and print arithmetic operations
	printf("%f\n", a * b);
	printf("%f\n", a + b);
}
```

### Preprocessing

In the source code of our program above, the lines that begin with a # are preprocessor directives. Preprocessor directives are processed by the preprocessor and are never seen by the compiler. The preprocessor performs text substitutes, macro expansion, comment removal and file inclusion. The first preprocessor in our program above is #include <stdio.h>  which instructs the preprocessor to include the header file stdio.h into our source. The next processor directive #define AVALUE 5, defines a text substitute. Once the preprocessor has completed processing our source code, every occurrence of the string AVALUE is substituted by the string 5.

We can instruct GCC to stop processing the source code after preprocessing and to send the preprocessed file to stdout.
```
gcc -E hello.c > hello.txt

gcc options:
    -E                       Preprocess only; do not compile, assemble or link
```
The output hello.txt has 851 lines. This is because the preprocessor includes the contents of the header file stdio.h, which in turn includes several other header files. Notice that comments have been removed and text substitution has been done.

### Compilation to Assembly Language
This part of the compilation process converts the preprocessed source code into assembly language.
```
gcc options:
  -S                       Compile only; do not assemble or link
```

### Assembly
This stage of the compilation process assembles the assembly language program generated into a machine language object file (.o).
```
gcc options:
  -c                       Compile and assemble, but do not link
```

When writing a program, the source code for various parts or functions of the program may be defined in separate source files. Since each source file is compiled into a separate object file, the object file produced from one source file may have a dependency on another object file. The function of the linker is to merge those object files so that any such dependencies are resolved.

## Libraries
### Static Libraries
We will create a small static library as an example to illustrate the linking process. First our main program test_link.c.
```
#include <stdio.h>

float cubed(float a);
float powerfour(float a);

int main()
{
	float x = 23.1415;
	float y = cubed(x);
	printf("%f\n", y);
	y = powerfour(x);
	printf("%f\n", y);

	return 0;
}
```
Notice that the function cubed and powerfour() are declared but not defined. The definition of cubed() and powerfour() will be placed in the next two files libcubed.c and libpowerfour.c. Below is the listing of libcubed.c.
```
float cubed(float a)
{
	return a * a * a;
}
```
And libpowerfour.c.
```
float powerfour(float a)
{
	return a * a * a * a;
}
```
To compile libcubed.c and libpowerfour.c as an object files, pass the -c option to gcc. This stops GCC from linking the object file into an executable and produces the object files libcubed.o and libpowerfour.o.
```
gcc -c libpowerfour.c libcubed.c
```
We will now combine libcubed.o and libpowerfour.o into a single static library.
```
ar rs libmymath.a libcubed.o libpowerfour.o
```
Let us try compiling the main program test_link.c without specifying the library object.
```
$ gcc -o test_link test_link.c 
/tmp/ccE11S3R.o: In function `main':
test_link.c:(.text+0x1d): undefined reference to `cubed'
test_link.c:(.text+0x4f): undefined reference to `powerfour'
collect2: error: ld returned 1 exit status
```
Now include the library file.
```
gcc -o test_link test_link.c -L. libmymath.a
```
Note the usage of the ‘-L’ flag - this flag tells the linker that libraries might be found in the given directory, in addition to the standard locations where the compiler looks for system libraries.

### dynamic libraries
As we described earlier, including static libraries while compiling programs actually merges the object files during the linking stage to produce a complete executable. There can be disadvantages to this. If there are several library files or they are very large, every executable that is generated by linking with these libraries will have a copy of the library code embedded in the executable. This makes the executable large. And when an executable is run, the executable file is actually mapped into memory before it is executed. This means it also occupies an unnecessarily large portion of memory. The solution to this is dynamic libraries.

It makes the executable smaller since they only contain references to and not the actual code the library functions. Also, only one copy of the code of a dynamic library needs to be maintained in main memory, and the operating system makes sure that every running process that refers to this library has its references resolved at run time.

The process of compiling the functions in the example above as a dynamic library consists of two steps.
```
gcc -fPIC -c libcubed.c libpowerfour.c
gcc -shared -Wl,-soname,libmymath.so -o libmymath.so libcubed.o libpowerfour.o
```
The -shared option tells gcc to produce a shared object file. -WI,soname,libmymath.so specifies the library soname.

Now, to link our main program to the dynamic libraries, we must compile it with
```
gcc -o test_link test_link.c -L. libmymath.so
```
The linker will look for the file ‘libmymath.so’ in the current directory (-L.), and link it to the program, but will place its object files inside the resulting executable file, ’test_link’.

On running the executable, instead of getting the expected output, we get the error.
```
$ ./test_link 
./test_link: error while loading shared libraries: libmymath.so: cannot open shared object file: No such file or directory
```
Normally, the system’s dynamic loader looks for shared libraries in some system specified directories (/lib and /usr/lib). When we build a new shared library that is not part of the system, we can use the LD_LIBRARY_PATH environment variable to tell the dynamic loader to look in other directories.

## Linking

### Static Linking
*Static linkers* such as the Unix `ld` program take as input a collection of relocatable object files and command line arguments and generate as output a fully linked executable object file that can be loaded and run. The input relocatable object files consist of various code and data sections. Instructions are in one section, initialized global variables are in another section, and uninitialized variables are in yet another section.

To build the executable, the linker must perform two main tasks:

* *Symbol resolution*. Object files define and reference *symbols*. The purpose of symbol resolution is to associate each symbol reference with exactly one symbol definition.
* *Relocation*. Compilers and assemblers generate code and data sections that start at address 0. The linker *relocates* these sections by associating a memory location with each symbol definition, and then modify all of the references to those symbols so that they point to this memory location.

### Object Files
Object files come in three forms:
* *Relocatable object file.* Contains binary code and data in a form that can be combined with other relocatable object files at compile time to create an executable object file.
* *Executable object file*. Contains binary code and data in a form that can be copied directly into memory and executed.
* *Shared object file*. A special type of relocatable object file that can be loaded into memory and linked dynamically, at either load time or run time.

Compilers and assemblers generate relocatable object files (including shared object files). Linkers generate executable object files.

### Relocatable Object Files


The linker checks each file in turn. If it is a library, the linker checks to see if any symbols referenced (i.e. used) in the previous object files but not defined (i.e. contained) in them, are in the library.
```
$ gcc -o test_link test_link.c -L. libmymath.so
$ gcc -o test_link -L. libmymath.so test_link.c
/tmp/ccWXGZDx.o: In function `main':
test_link.c:(.text+0x1d): undefined reference to `cubed'
test_link.c:(.text+0x4f): undefined reference to `powerfour'
collect2: error: ld returned 1 exit status
```
```
--as-needed
--no-as-needed
```
This option affects ELF DT_NEEDED tags for dynamic libraries mentioned on the command line after the --as-needed option. Normally the linker will add a DT_NEEDED tag for each dynamic library mentioned on the command line, regardless of whether the library is actually needed or not. --as-needed causes a DT_NEEDED tag to only be emitted for a library that at that point in the link satisfies a non-weak undefined symbol reference from a regular object file or, if the library is not found in the DT_NEEDED lists of other libraries, a non-weak undefined symbol reference from another dynamic library. Object files or libraries appearing on the command line after the library in question do not affect whether the library is seen as needed. This is similar to the rules for extraction of object files from archives. --no-as-needed restores the default behaviour.
```
$ gcc -o test_link test_link.c -L. libmymath.so
$ readelf -d test_link

Dynamic section at offset 0xe18 contains 25 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [libmymath.so]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
 0x000000000000000c (INIT)               0x4005b8
 0x000000000000000d (FINI)               0x400824
 0x0000000000000019 (INIT_ARRAY)         0x600e00
 0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)
 0x000000000000001a (FINI_ARRAY)         0x600e08
 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)
 0x000000006ffffef5 (GNU_HASH)           0x400298
 0x0000000000000005 (STRTAB)             0x400420
 0x0000000000000006 (SYMTAB)             0x4002d0
 0x000000000000000a (STRSZ)              202 (bytes)
 0x000000000000000b (SYMENT)             24 (bytes)
 0x0000000000000015 (DEBUG)              0x0
 0x0000000000000003 (PLTGOT)             0x601000
 0x0000000000000002 (PLTRELSZ)           120 (bytes)
 0x0000000000000014 (PLTREL)             RELA
 0x0000000000000017 (JMPREL)             0x400540
 0x0000000000000007 (RELA)               0x400528
 0x0000000000000008 (RELASZ)             24 (bytes)
 0x0000000000000009 (RELAENT)            24 (bytes)
 0x000000006ffffffe (VERNEED)            0x400508
 0x000000006fffffff (VERNEEDNUM)         1
 0x000000006ffffff0 (VERSYM)             0x4004ea
 0x0000000000000000 (NULL)               0x0
```

```
$ gcc -Wl,--no-as-needed -o test_link -L. libmymath.so -libverbs test_link.c
$ readelf -d test_link

Dynamic section at offset 0xe08 contains 26 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [libmymath.so]
 0x0000000000000001 (NEEDED)             Shared library: [libibverbs.so.1]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
 0x000000000000000c (INIT)               0x4005c8
 0x000000000000000d (FINI)               0x400834
 0x0000000000000019 (INIT_ARRAY)         0x600df0
 0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)
 0x000000000000001a (FINI_ARRAY)         0x600df8
 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)
 0x000000006ffffef5 (GNU_HASH)           0x400298
 0x0000000000000005 (STRTAB)             0x400420
 0x0000000000000006 (SYMTAB)             0x4002d0
 0x000000000000000a (STRSZ)              218 (bytes)
 0x000000000000000b (SYMENT)             24 (bytes)
 0x0000000000000015 (DEBUG)              0x0
 0x0000000000000003 (PLTGOT)             0x601000
 0x0000000000000002 (PLTRELSZ)           120 (bytes)
 0x0000000000000014 (PLTREL)             RELA
 0x0000000000000017 (JMPREL)             0x400550
 0x0000000000000007 (RELA)               0x400538
 0x0000000000000008 (RELASZ)             24 (bytes)
 0x0000000000000009 (RELAENT)            24 (bytes)
 0x000000006ffffffe (VERNEED)            0x400518
 0x000000006fffffff (VERNEEDNUM)         1
 0x000000006ffffff0 (VERSYM)             0x4004fa
 0x0000000000000000 (NULL)               0x0
```

## QEMU configure
```
configure options:
--extra-cflags=CFLAGS    append extra C compiler flags QEMU_CFLAGS
--extra-ldflags=LDFLAGS  append extra linker flags LDFLAGS
```