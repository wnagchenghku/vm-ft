1. libev

1. Use a timer and stop, reinitialise and start it on activity.
This is the most obvious, but not the most simple way: In the beginning, start the watcher:
ev_timer_init (timer, callback, 60., 0.);
ev_timer_start (loop, timer);
Then, each time there is some activity, "ev_timer_stop" it, initialise it and start it again:
ev_timer_stop (loop, timer);
ev_timer_set (timer, 60., 0.);
ev_timer_start (loop, timer);
This is relatively simple to implement, but means that each time there is some activity, libev will first have to remove the timer from its internal data structure and then add it again. Libev tries to be fast, but it's still not a constant-time operation.
2. Use a timer and re-start it with "ev_timer_again" inactivity.
This is the easiest way, and involves using "ev_timer_again" instead of "ev_timer_start".

In the following description, uppercase "TYPE" in names stands for the watcher type, e.g. "ev_TYPE_start" can mean "ev_timer_start" for timer watchers and "ev_io_start" for I/O watchers.

A watcher is an opaque structure that you allocate and register to record your interest in some event. To make a concrete example, imagine you want to wait for STDIN to become readable, you would create an "ev_io" watcher for that:

static void my_cb (struct ev_loop *loop, ev_io *w, int revents)
{
  ev_io_stop (w);
  ev_break (loop, EVBREAK_ALL);
}

struct ev_loop *loop = ev_default_loop (0);

ev_io stdin_watcher;

ev_init (&stdin_watcher, my_cb);
ev_io_set (&stdin_watcher, STDIN_FILENO, EV_READ);
ev_io_start (loop, &stdin_watcher);

ev_run (loop, 0);
As you can see, you are responsible for allocating the memory for your watcher structures (and it is usually a bad idea to do this on the stack).
Each watcher has an associated watcher structure (called "struct ev_TYPE" or simply "ev_TYPE", as typedefs are provided for all watcher structs).

Each watcher structure must be initialised by a call to "ev_init (watcher *, callback)", which expects a callback to be provided. This callback is invoked each time the event occurs (or, in the case of I/O watchers, each time the event loop detects that the file descriptor given is readable and/or writable).

Each watcher type further has its own "ev_TYPE_set (watcher *, ...)" macro to configure it, with arguments specific to the watcher type. There is also a macro to combine initialisation and setting in one call: "ev_TYPE_init (watcher *, callback, ...)".

To make the watcher actually watch out for events, you have to start it with a watcher-specific start function ("ev_TYPE_start (loop, watcher *)"), and you can stop watching for events at any time by calling the corresponding stop function ("ev_TYPE_stop (loop, watcher *)".

As long as your watcher is active (has been started but not stopped) you must not touch the values stored in it. Most specifically you must never reinitialise it or call its "ev_TYPE_set" macro.

Each and every callback receives the event loop pointer as first, the registered watcher structure as second, and a bitset of received events as third argument.


2. chardev can be Unix socket

3. portno is hard coded.

4. add explanations about ./configure, no as needed, LD_LIBRARY_PATH

5. make verbose
